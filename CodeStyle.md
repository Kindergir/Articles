# Code style
>Нос трубой, хвост - по ветру, код - в чистоте.

За основу предлагаю взять MS-кодстайл: https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/. Здесь будут особые договорённости.
## Обязательное и простое
1. Фигурные скобки вокруг тела if, for, foreach, etc ставятся, только если в теле больше одной строки.
Каждая фигурная скобка - в новой строке.
```csharp
// Так делай
if (Ok)
return OkResult;
```
```csharp
// А так не делай
if (Ok) // Bad
{    
    return OkResult;
}
```
2. Лямбда-выражение в качестве тела метода или get-свойства разрешена, только если содержит одну строку. В LINQ-выражениях допустима при любом количестве строк, но соблюдаем разумные пределы : )
```csharp
// Так можно
public static bool IsTeamLeadSatisfyed => true;

public int GetDeveloperSalary(int id) => id * 100000;
```
4. Если в методе столько аргументов, что они не уместились в одну строку, то КАЖДЫЙ, включая первый, пишется с новой строки. Действует как для объявления, так и для вызова метода.
```csharp
// Так можно
public int GetDeveloperSalary(
    int id,
    bool isGood)
{
    // bla bla
}

// И так тоже
public int GetDeveloperSalary(int id, bool isGood)
{
    // bla bla
}
```
```csharp
// А так не стоит
public int GetDeveloperSalary(int id, bool isGood,
    bool reallyBad, int count)
{
    // bla bla
}
```
4. Используем `var`, когда тип понятен из правой части. Концентрируем типы справа от имени поля/переменной.
5. НЕ используем регионы. Регионы - признак оверхеда по количеству логики в коде. Исключение: огромные DTO, с которыми ничего не поделать (структура определяется не только нами).
6. Временно не используем `new()` (связано со старым клиентом).
## Конструирование классов
1. Методы класса называются по правилу CamelCase, обязательно содержат глагол в названии.
2. Свойства классов могут быть только публичными. Название соблюдает правила CamelCase.
3. Поля класса могут быть только приватными, публичных полей не бывает. Приватные поля называются _privateField.
4. Если поле может быть `readonly`, нужно явно прописать `readonly`-модификатор.
4. `base` и `this` предпочтительно не указывать, если компилятор воспринимает наличие и отсутствие одинаково (например, указывать необходимо, если явно вызывается метод `base` из перегрузки).
5. Публичные методы обязательно выше приватных. Если метод `Start` вызывает метод `Stop`, то метод `Stop` располагается под методом `Start`. Это помогает концентрироваться на основной логике.
6. Все классы должны явно помечаться `public` или `internal`.
2. Все приватные поля, методы и тд явно помечаются `private`.
3. Все классы, которые не предполагается расширять, явно помечаются `sealed`.
```csharp
public class Example
{
    private const int NiceConst = 1000;
    private readonly string _niceField;

    public Example(string niceField)
    {
        _niceField = niceField;
    }

    public int GeneralProp { get; set; }

    public int CalculateSmth(int from, int to)
    {
        // bla bla
        var value = CalculateSmthInternal();
        return value * to * from;
    }

    private int CalculateSmthInternal()
    {
        // bla bla
    }
}
```
## Коллекции
1. Избегайте `IEnumerable<>`. `IEnumerable<>` можно использовать, если и только если коллекция намеренно создана неограниченного размера, а вычисление - отложенным.
2. Для передаваемых параметров и возвращаемых значений лучше всего использовать `IReadOnlyCollection<>`. Мотивация: пользователю кода, либо же следующему пришедшему автору будет сложнее использовать код неожиданным образом. Также изменение `IReadOnlyCollection<>` на любой другой тип бросается в глаза на ревью - проще отследить изменение поведения внутри.
## Асинхронное API
1. Для каждого метода асинхронного API необходимо добавлять параметр `CancellationToken token`.
2. Необходимо избегать смешения sync и async кода!
## Всякое оптимизирующее
1. При использовании `IDisposable` определяем зону видимости: допустимо использовать `using var`, но только если это не увеличивает её.
2. Для типов-коллекций с изменяемой размерностью (`List<>`, `StringBuilder`, etc) предпочтительно указывать Capacity сразу же при объявлении в конструкторе.
## Всякое разное
1. Доменные модели и DTO не содержат логики. Мапперы и парсеры пишутся отдельно.
2. Константы в коде определяются в отдельных классах или как приватные поля. Обязательно помечаются `const` или `static readonly`. Однако, при создании константы необходимо убедиться, что не стоит выносить её в настройки приложения. Магических чисел в коде не бывает : )
3. Приватные (вложенные) классы разрешены, если вложенный класс является частью модели (доменной или DTO). Для передачи множества данных между приватными методами класса, например, >1 возвращаемого значения, предпочтительнее анонимные типы.
